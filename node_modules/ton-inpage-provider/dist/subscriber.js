"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = __importDefault(require("./index"));
class Subscriber {
    constructor() {
    }
    static async transactions(address) {
        const subscription = await index_1.default.subscribe('transactionsFound', {
            address
        });
        return new Transformer((extractor) => {
            subscription.on('data', extractor);
        }, identity);
    }
    static async states(address) {
        const subscription = await index_1.default.subscribe('contractStateChanged', {
            address
        });
        return new Transformer((extractor) => {
            subscription.on('data', extractor);
        }, identity);
    }
}
//
// async function test() {
//   const subscriber = await Subscriber.transactions(new Address('asd'));
//   subscriber.filter((item) => {
//     return item.transactions;
//   }).skip(1)
//     .map((item) => {
//
//     });
// }
function identity(data) {
    return data;
}
class Transformer {
    constructor(makeProducer, extractor, transformer) {
        this.makeProducer = makeProducer;
        this.extractor = extractor;
        this.transformer = transformer;
    }
    next() {
        return new Promise((resolve) => {
            this.makeProducer((event) => {
                this.extractor(event, resolve);
            });
        });
    }
    merge(other) {
        return new Transformer((extractor) => {
            this.makeProducer(extractor);
            other.makeProducer(extractor);
        }, this.extractor);
    }
    filter(f) {
        return new Transformer(this.makeProducer, (event, handler) => {
            const item = this.transformer(event);
            if (item !== undefined && f(item)) {
                handler(item);
            }
        }, this.transformer);
    }
    filterMap(f) {
        // return new Transformer<T, U>(this.makeProducer, (event, handler) => {
        //   const item = this.extractor(event);
        //   return item !== undefined ? f(item) : undefined;
        // }, (item) => {
        //
        // });
    }
    map(f) {
        return this.filterMap(f);
    }
    flatMap(f) {
        return new Transformer((extractor) => {
        }, (event) => {
            const items = this.extractor(event);
        });
    }
    skip(n) {
        const state = {
            index: 0
        };
        return new Transformer(this.makeProducer, (event) => {
            const item = this.extractor(event);
            if (item === undefined) {
                return undefined;
            }
            if (state.index < n) {
                ++state.index;
                return undefined;
            }
            return item;
        });
    }
    skipWhile(f) {
        const state = {
            shouldSkip: true
        };
        return new Transformer(this.makeProducer, (event) => {
            const item = this.extractor(event);
            if (item === undefined) {
                return undefined;
            }
            if (state.shouldSkip && f(item)) {
                return undefined;
            }
            state.shouldSkip = false;
            return item;
        });
    }
}
