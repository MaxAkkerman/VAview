"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TvmException = exports.Contract = void 0;
const utils_1 = require("./utils");
const index_1 = __importDefault(require("./index"));
class Contract {
    constructor(abi, address) {
        if (!Array.isArray(abi.functions)) {
            throw new Error('Invalid abi. Functions array required');
        }
        if (!Array.isArray(abi.events)) {
            throw new Error('Invalid abi. Events array required');
        }
        this._abi = JSON.stringify(abi);
        this._functions = abi.functions.reduce((functions, item) => {
            functions[item.name] = { inputs: item.inputs || [], outputs: item.outputs || [] };
            return functions;
        }, {});
        this._events = abi.events.reduce((events, item) => {
            events[item.name] = { inputs: item.inputs || [] };
            return events;
        }, {});
        this._address = address;
        class ContractMethod {
            constructor(functionAbi, abi, address, method, params) {
                this.functionAbi = functionAbi;
                this.abi = abi;
                this.address = address;
                this.method = method;
                this.params = utils_1.transformToSerializedObject(params);
            }
            async send(args) {
                const { transaction } = await index_1.default.api.sendMessage({
                    sender: args.from.toString(),
                    recipient: this.address.toString(),
                    amount: args.amount,
                    bounce: args.bounce == null ? true : args.bounce,
                    payload: {
                        abi: this.abi,
                        method: this.method,
                        params: this.params
                    }
                });
                return transaction;
            }
            async sendExternal(args) {
                let { transaction, output } = await index_1.default.api.sendExternalMessage({
                    publicKey: args.publicKey,
                    recipient: this.address.toString(),
                    stateInit: args.stateInit,
                    payload: {
                        abi: this.abi,
                        method: this.method,
                        params: this.params
                    }
                });
                if (output != null) {
                    output = utils_1.transformToParsedObject(this.functionAbi.outputs, output);
                }
                return { transaction, output };
            }
            async call(args = {}) {
                let { output, code } = await index_1.default.api.runLocal({
                    address: this.address.toString(),
                    cachedState: args.cachedState,
                    functionCall: {
                        abi: this.abi,
                        method: this.method,
                        params: this.params
                    }
                });
                if (output == null || code != 0) {
                    throw new TvmException(code);
                }
                else {
                    output = utils_1.transformToParsedObject(this.functionAbi.outputs, output);
                    return output;
                }
            }
        }
        this._methods = new Proxy({}, {
            get: (_object, method) => {
                const rawAbi = this._functions[method];
                return (params) => new ContractMethod(rawAbi, this._abi, this._address, method, params);
            }
        });
    }
    get methods() {
        return this._methods;
    }
    get address() {
        return this._address;
    }
    async decodeTransaction(args) {
        try {
            const result = await index_1.default.api.decodeTransaction({
                transaction: args.transaction,
                abi: this._abi,
                method: args.methods
            });
            if (result == null) {
                return undefined;
            }
            let { method, input, output } = result;
            const rawAbi = this._functions[method];
            if (rawAbi.inputs != null) {
                input = utils_1.transformToParsedObject(rawAbi.inputs, input);
            }
            else {
                input = {};
            }
            if (rawAbi.outputs != null) {
                output = utils_1.transformToParsedObject(rawAbi.outputs, output);
            }
            else {
                output = {};
            }
            return { method, input, output };
        }
        catch (_) {
            return undefined;
        }
    }
    async decodeTransactionEvents(args) {
        try {
            const { events } = await index_1.default.api.decodeTransactionEvents({
                transaction: args.transaction,
                abi: this._abi
            });
            for (let item of events) {
                let { event, data } = item;
                const rawAbi = this._events[event];
                if (rawAbi.inputs != null) {
                    item.data = utils_1.transformToParsedObject(rawAbi.inputs, data);
                }
                else {
                    item.data = {};
                }
            }
            return events;
        }
        catch (e) {
            console.debug(e);
            return [];
        }
    }
    async decodeInputMessage(args) {
        try {
            const result = await index_1.default.api.decodeInput({
                abi: this._abi,
                body: args.body,
                internal: args.internal,
                method: args.methods
            });
            if (result == null) {
                return undefined;
            }
            let { method, input } = result;
            const rawAbi = this._functions[method];
            if (rawAbi.inputs != null) {
                input = utils_1.transformToParsedObject(rawAbi.inputs, input);
            }
            else {
                input = {};
            }
            return { method, input };
        }
        catch (_) {
            return undefined;
        }
    }
    async decodeOutputMessage(args) {
        try {
            const result = await index_1.default.api.decodeOutput({
                abi: this._abi,
                body: args.body,
                method: args.methods
            });
            if (result == null) {
                return undefined;
            }
            let { method, output } = result;
            const rawAbi = this._functions[method];
            if (rawAbi.outputs != null) {
                output = utils_1.transformToParsedObject(rawAbi.outputs, output);
            }
            else {
                output = {};
            }
            return { method, output };
        }
        catch (_) {
            return undefined;
        }
    }
}
exports.Contract = Contract;
class TvmException extends Error {
    constructor(code) {
        super(`TvmException: ${code}`);
        this.code = code;
    }
}
exports.TvmException = TvmException;
