"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUniqueId = exports.transformToSerializedObject = exports.transformToParsedObject = exports.AddressLiteral = exports.Address = void 0;
class Address {
    constructor(address) {
        this._address = address;
    }
    toString() {
        return this._address;
    }
}
exports.Address = Address;
class AddressLiteral extends Address {
    constructor(address) {
        super(address);
    }
}
exports.AddressLiteral = AddressLiteral;
function transformToParsedObject(params, object) {
    params.forEach((param) => {
        object[param.name] = parseToken(param, object[param.name]);
    });
    return object;
}
exports.transformToParsedObject = transformToParsedObject;
function parseToken(param, token) {
    var _a;
    if (param.type.startsWith('map')) {
        let [keyType, valueType] = param.type.split(',');
        keyType = keyType.slice(4);
        valueType = valueType.slice(0, -1);
        token.forEach(([key, value], i) => {
            token[i] = [parseToken({
                    name: '',
                    type: keyType
                }, key), parseToken({
                    name: '',
                    type: valueType,
                    components: param.components
                }, value)];
        });
        return token;
    }
    else {
        const rawType = param.type.endsWith('[]') ? param.type.slice(0, -2) : param.type;
        const isArray = rawType != param.type;
        if (isArray) {
            const rawParam = { name: param.name, type: rawType, components: param.components };
            token.forEach((item, i) => {
                token[i] = parseToken(rawParam, item);
            });
            return token;
        }
        else if (rawType == 'tuple') {
            (_a = param.components) === null || _a === void 0 ? void 0 : _a.forEach((itemParam) => {
                const tupleItem = token[itemParam.name];
                token[itemParam.name] = parseToken(itemParam, tupleItem);
            });
            return token;
        }
        else if (rawType == 'address') {
            return new Address(token);
        }
        else {
            return token;
        }
    }
}
function transformToSerializedObject(object) {
    return serializeToken(object);
}
exports.transformToSerializedObject = transformToSerializedObject;
function serializeToken(token) {
    // custom types go first
    if (token instanceof Address) {
        return token.toString();
    }
    if (Array.isArray(token)) {
        token.forEach((value, i) => {
            token[i] = serializeToken(value);
        });
        return token;
    }
    else if (typeof token === 'object') {
        Object.keys(token).forEach((key) => {
            token[key] = serializeToken(token[key]);
        });
        return token;
    }
    else {
        return token;
    }
}
const MAX = 4294967295;
let idCounter = Math.floor(Math.random() * MAX);
function getUniqueId() {
    idCounter = (idCounter + 1) % MAX;
    return idCounter;
}
exports.getUniqueId = getUniqueId;
