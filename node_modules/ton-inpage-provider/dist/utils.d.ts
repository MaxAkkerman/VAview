import { TokensObject } from './models';
export declare type UniqueArray<T> = T extends readonly [infer X, ...infer Rest] ? InArray<Rest, X> extends true ? ['Encountered value with duplicates:', X] : readonly [X, ...UniqueArray<Rest>] : T;
export declare type InArray<T, X> = T extends readonly [X, ...infer _Rest] ? true : T extends readonly [X] ? true : T extends readonly [infer _, ...infer Rest] ? InArray<Rest, X> : false;
declare type ArrayItemType<T extends readonly unknown[]> = T extends readonly (infer Ts)[] ? Ts : never;
declare type TokenValueUint = 'uint8' | 'uint16' | 'uint32' | 'uint64' | 'uint128' | 'uint256';
declare type TokenValueInt = 'int8' | 'int16' | 'int32' | 'int64' | 'int128' | 'int256';
declare type TokenValueTuple = 'tuple';
declare type TokenValueBool = 'bool';
declare type TokenValueCell = 'cell';
declare type TokenValueAddress = 'address';
declare type TokenValueBytes = 'bytes';
declare type TokenValueGram = 'gram';
declare type TokenValueTime = 'time';
declare type TokenValueExpire = 'expire';
declare type TokenValuePublicKey = 'pubkey';
declare type TokenValue<T, C> = T extends TokenValueUint | TokenValueInt | TokenValueGram | TokenValueTime | TokenValueExpire ? string | number : T extends TokenValueBool ? boolean : T extends TokenValueCell | TokenValueBytes | TokenValuePublicKey ? string : T extends TokenValueAddress ? Address : T extends TokenValueTuple ? MergeObjectsArray<C> : T extends `${infer K}[]` ? TokenValue<K, C>[] : T extends `map(${infer K},${infer V})` ? (readonly [TokenValue<K, undefined>, TokenValue<V, C>])[] : never;
declare type TokenObject<O> = O extends {
    name: infer K;
    type: infer T;
    components?: infer C;
} ? K extends string ? {
    [P in K]: TokenValue<T, C>;
} : never : never;
declare type MergeObjectsArray<A> = A extends readonly [infer T, ...infer Ts] ? (TokenObject<T> & MergeObjectsArray<[...Ts]>) : A extends readonly [infer T] ? TokenObject<T> : A extends readonly [] ? {} : never;
declare type AbiFunction<C> = C extends {
    functions: infer F;
} ? F extends readonly unknown[] ? ArrayItemType<F> : never : never;
export declare type AbiFunctionName<C> = AbiFunction<C>['name'];
declare type PickFunction<C, T extends AbiFunctionName<C>> = Extract<AbiFunction<C>, {
    name: T;
}>;
export declare type AbiFunctionParams<C, T extends AbiFunctionName<C>> = MergeObjectsArray<PickFunction<C, T>['inputs']>;
export declare type AbiFunctionOutput<C, T extends AbiFunctionName<C>> = MergeObjectsArray<PickFunction<C, T>['outputs']>;
declare type AbiEvent<C> = C extends {
    events: infer E;
} ? E extends readonly unknown[] ? ArrayItemType<E> : never : never;
export declare type AbiEventName<C> = AbiEvent<C>['name'];
declare type PickEvent<C, T extends AbiEventName<C>> = Extract<AbiEvent<C>, {
    name: T;
}>;
export declare type AbiEventParams<C, T extends AbiEventName<C>> = MergeObjectsArray<PickEvent<C, T>['inputs']>;
export declare class Address {
    private readonly _address;
    constructor(address: string);
    toString(): string;
}
export declare class AddressLiteral<T extends string> extends Address {
    constructor(address: CheckAddress<T>);
}
declare type CheckAddress<T extends string> = AddressImpl<T, Lowercase<T>>;
declare type AddressPrefix = '0:' | '-1:';
declare type AddressImpl<T, Tl extends string> = Tl extends `${AddressPrefix}${infer Hash}` ? true extends IsHexString<Hash, []> ? T : never : never;
declare type HexSymbol = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f';
declare type HexByte = `${HexSymbol}${HexSymbol}`;
declare type IsHexString<T extends string, L extends readonly number[]> = T extends `${HexByte}${infer Tail}` ? IsHexString<Tail, [...L, 0]> : T extends '' ? L['length'] extends 32 ? true : never : never;
declare type AbiParamKind = TokenValueUint | TokenValueInt | TokenValueTuple | TokenValueBool | TokenValueCell | TokenValueAddress | TokenValueBytes | TokenValueGram | TokenValueTime | TokenValueExpire | TokenValuePublicKey;
declare type AbiParamArray = `${AbiParamKind}[]`;
declare type AbiParamMapping = `map(${TokenValueUint | TokenValueInt | TokenValueAddress},${AbiParamKind | `${AbiParamKind}[]`})`;
export declare type AbiParam = {
    name: string;
    type: AbiParamKind | AbiParamArray | AbiParamMapping;
    components?: AbiParam[];
};
export declare type ParsedAbiToken = boolean | string | number | Address | {
    [K in string]: ParsedAbiToken;
} | ParsedAbiToken[] | (readonly [ParsedAbiToken, ParsedAbiToken])[];
export declare type ParsedTokensObject = {
    [K in string]: ParsedAbiToken;
};
export declare function transformToParsedObject(params: AbiParam[], object: TokensObject): ParsedTokensObject;
export declare function transformToSerializedObject(object: ParsedTokensObject): TokensObject;
export declare function getUniqueId(): number;
export {};
