"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscriber = void 0;
const utils_1 = require("./utils");
class Subscriber {
    constructor(ton) {
        this.ton = ton;
        this.subscriptions = {};
    }
    transactions(address) {
        return this._addSubscription('transactionsFound', address);
    }
    states(address) {
        return this._addSubscription('contractStateChanged', address);
    }
    async unsubscribe() {
        const subscriptions = Object.assign({}, this.subscriptions);
        for (const address of Object.keys(this.subscriptions)) {
            delete this.subscriptions[address];
        }
        await Promise.all(Object.values(subscriptions)
            .map((item) => {
            const events = Object.assign({}, item);
            for (const event of Object.keys(events)) {
                delete item[event];
            }
            return Promise.all(Object.values(events).map((eventData) => {
                if (eventData == null) {
                    return;
                }
                return eventData.subscription.then((item) => {
                    return item.unsubscribe();
                }).catch(() => {
                    // ignore
                });
            }));
        }));
    }
    _addSubscription(event, address) {
        const id = utils_1.getUniqueId();
        return new StreamImpl((onData, onEnd) => {
            let subscriptions = this.subscriptions[address.toString()];
            let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];
            if (eventData == null) {
                const handlers = {
                    [id]: { onData, onEnd }
                };
                eventData = {
                    subscription: this.ton.subscribe(event, {
                        address
                    }).then((subscription) => {
                        subscription.on('data', (data) => {
                            Object.values(handlers).forEach(({ onData }) => {
                                onData(data);
                            });
                        });
                        subscription.on('unsubscribed', () => {
                            Object.values(handlers).forEach(({ onEnd }) => {
                                delete handlers[id];
                                onEnd();
                            });
                        });
                        return subscription;
                    }).catch((e) => {
                        console.error(e);
                        Object.values(handlers).forEach(({ onEnd }) => {
                            delete handlers[id];
                            onEnd();
                        });
                        throw e;
                    }),
                    handlers
                };
                if (subscriptions == null) {
                    subscriptions = {
                        [event]: eventData
                    };
                    this.subscriptions[address.toString()] = subscriptions;
                }
                else {
                    subscriptions[event] = eventData;
                }
            }
            else {
                eventData.handlers[id] = { onData, onEnd };
            }
        }, () => {
            const subscriptions = this.subscriptions[address.toString()];
            if (subscriptions == null) {
                return;
            }
            const eventData = subscriptions[event];
            if (eventData != null) {
                delete eventData.handlers[id];
                if (Object.keys(eventData.handlers).length === 0) {
                    const subscription = eventData.subscription;
                    delete subscriptions[event];
                    subscription
                        .then((subscription) => subscription.unsubscribe())
                        .catch(console.debug);
                }
            }
            if (Object.keys(subscriptions).length === 0) {
                delete this.subscriptions[address.toString()];
            }
        }, identity);
    }
}
exports.Subscriber = Subscriber;
function identity(event, handler) {
    handler(event);
}
class StreamImpl {
    constructor(makeProducer, stopProducer, extractor) {
        this.makeProducer = makeProducer;
        this.stopProducer = stopProducer;
        this.extractor = extractor;
    }
    first() {
        return new Promise((resolve, reject) => {
            this.makeProducer((event) => {
                this.extractor(event, (item) => {
                    this.stopProducer();
                    resolve(item);
                });
            }, () => reject(new Error('Subscription closed')));
        });
    }
    on(handler) {
        this.makeProducer((event) => {
            this.extractor(event, handler);
        }, () => {
        });
    }
    merge(other) {
        return new StreamImpl((onEvent, onEnd) => {
            const state = {
                counter: 0
            };
            const checkEnd = () => {
                if (++state.counter == 2) {
                    onEnd();
                }
            };
            this.makeProducer(onEvent, checkEnd);
            other.makeProducer(onEvent, checkEnd);
        }, () => {
            this.stopProducer();
            other.stopProducer();
        }, this.extractor);
    }
    filter(f) {
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => {
            this.extractor(event, (item) => {
                if (f(item)) {
                    handler(item);
                }
            });
        });
    }
    filterMap(f) {
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => {
            this.extractor(event, (item) => {
                const newItem = f(item);
                if (newItem !== undefined) {
                    handler(newItem);
                }
            });
        });
    }
    map(f) {
        return this.filterMap(f);
    }
    flatMap(f) {
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => {
            this.extractor(event, (item) => {
                const items = f(item);
                for (const newItem of items) {
                    handler(newItem);
                }
            });
        });
    }
    skip(n) {
        const state = {
            index: 0
        };
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => {
            this.extractor(event, (item) => {
                if (state.index >= n) {
                    handler(item);
                }
                else {
                    ++state.index;
                }
            });
        });
    }
    skipWhile(f) {
        const state = {
            shouldSkip: true
        };
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => {
            this.extractor(event, (item) => {
                if (!state.shouldSkip || !f(item)) {
                    state.shouldSkip = false;
                    handler(item);
                }
            });
        });
    }
}
