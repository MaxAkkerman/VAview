import { AbiEventName, AbiEventParams, AbiFunctionName, AbiFunctionOutput, AbiFunctionParams, Address, UniqueArray } from './utils';
import { FullContractState, Transaction } from './models';
export declare class Contract<Abi> {
    private readonly _abi;
    private readonly _functions;
    private readonly _events;
    private readonly _address;
    private readonly _methods;
    constructor(abi: Abi, address: Address);
    get methods(): IContractMethods<Abi>;
    get address(): Address;
    decodeTransaction(args: IDecodeTransaction<Abi>): Promise<IDecodedTransaction<Abi, AbiFunctionName<Abi>> | undefined>;
    decodeTransactionEvents(args: IDecodeTransactionEvents): Promise<IDecodedEvent<Abi, AbiEventName<Abi>>[]>;
    decodeInputMessage(args: IDecodeInput<Abi>): Promise<IDecodedInput<Abi, AbiFunctionName<Abi>> | undefined>;
    decodeOutputMessage(args: IDecodeOutput<Abi>): Promise<IDecodedOutput<Abi, AbiFunctionName<Abi>> | undefined>;
}
export declare class TvmException extends Error {
    readonly code: number;
    constructor(code: number);
}
interface IContractMethod<I, O> {
    /**
     * Target contract address
     */
    readonly address: Address;
    readonly abi: string;
    readonly method: string;
    readonly params: I;
    /**
     * Sends internal message and returns wallet transactions
     *
     * @param args
     */
    send(args: ISendInternal): Promise<Transaction>;
    /**
     * Sends external message and returns contract transaction with parsed output
     *
     * @param args
     */
    sendExternal(args: ISendExternal): Promise<{
        transaction: Transaction;
        output?: O;
    }>;
    /**
     * Runs message locally
     */
    call(args?: ICall): Promise<O>;
}
declare type IContractMethods<C> = {
    [K in AbiFunctionName<C>]: (params: AbiFunctionParams<C, K>) => IContractMethod<AbiFunctionParams<C, K>, AbiFunctionOutput<C, K>>;
};
interface ISendInternal {
    from: Address;
    amount: string;
    /**
     * @default true
     */
    bounce?: boolean;
}
interface ISendExternal {
    publicKey: string;
    stateInit?: string;
}
interface ICall {
    cachedState?: FullContractState;
}
interface IDecodeTransaction<Abi> {
    transaction: Transaction;
    methods: UniqueArray<AbiFunctionName<Abi>[]>;
}
declare type IDecodedTransaction<Abi, T> = T extends AbiFunctionName<Abi> ? {
    method: T;
    input: AbiFunctionParams<Abi, T>;
    output: AbiFunctionOutput<Abi, T>;
} : never;
interface IDecodeInput<Abi> {
    body: string;
    methods: UniqueArray<AbiFunctionName<Abi>[]>;
    internal: boolean;
}
declare type IDecodedInput<Abi, T> = T extends AbiFunctionName<Abi> ? {
    method: T;
    input: AbiFunctionParams<Abi, T>;
} : never;
interface IDecodeOutput<Abi> {
    body: string;
    methods: UniqueArray<AbiFunctionName<Abi>[]>;
}
declare type IDecodedOutput<Abi, T> = T extends AbiFunctionName<Abi> ? {
    method: T;
    output: AbiFunctionOutput<Abi, T>;
} : never;
interface IDecodeTransactionEvents {
    transaction: Transaction;
}
declare type IDecodedEvent<Abi, T> = T extends AbiEventName<Abi> ? {
    event: T;
    data: AbiEventParams<Abi, T>;
} : never;
export {};
