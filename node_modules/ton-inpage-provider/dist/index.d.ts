import { ProviderEvent, ProviderEventData, ProviderMethod, ProviderRequestParams, ProviderResponse } from './api';
import { Transaction, TransactionsBatchInfo } from './models';
import { Address } from './utils';
import { Subscriber } from './stream';
export * from './api';
export * from './models';
export * from './permissions';
export * from './contract';
export * from './stream';
export { Address, AddressLiteral } from './utils';
export interface TonRequest<T extends ProviderMethod> {
    method: T;
    params: ProviderRequestParams<T>;
}
export interface Ton {
    addListener<T extends ProviderEvent>(eventName: T, listener: (data: ProviderEventData<T>) => void): void;
    removeListener<T extends ProviderEvent>(eventName: T, listener: (data: ProviderEventData<T>) => void): void;
    on<T extends ProviderEvent>(eventName: T, listener: (data: ProviderEventData<T>) => void): void;
    once<T extends ProviderEvent>(eventName: T, listener: (data: ProviderEventData<T>) => void): void;
    prependListener<T extends ProviderEvent>(eventName: T, listener: (data: ProviderEventData<T>) => void): void;
    prependOnceListener<T extends ProviderEvent>(eventName: T, listener: (data: ProviderEventData<T>) => void): void;
    request<T extends ProviderMethod>(data: TonRequest<T>): Promise<ProviderResponse<T>>;
}
declare type RpcMethod<P extends ProviderMethod> = ProviderRequestParams<P> extends {} ? (args: ProviderRequestParams<P>) => Promise<ProviderResponse<P>> : () => Promise<ProviderResponse<P>>;
declare type ProviderApiMethods = {
    [P in ProviderMethod]: RpcMethod<P>;
};
export declare function hasTonProvider(): Promise<boolean>;
/**
 * Modifies knownTransactions array, merging it with new transactions.
 * All arrays are assumed to be sorted by descending logical time.
 *
 * > Note! This method does not remove duplicates.
 *
 * @param knownTransactions
 * @param newTransactions
 * @param info
 */
export declare function mergeTransactions(knownTransactions: Transaction[], newTransactions: Transaction[], info: TransactionsBatchInfo): Transaction[];
export interface ISubscription<T extends ProviderEvent> {
    /**
     * Fires on each incoming event with the event object as argument.
     *
     * @param eventName 'data'
     * @param listener
     */
    on(eventName: 'data', listener: (data: ProviderEventData<T>) => void): this;
    /**
     * Fires on successful re-subscription
     *
     * @param eventName 'subscribed'
     * @param listener
     */
    on(eventName: 'subscribed', listener: () => void): this;
    /**
     * Fires on unsubscription
     *
     * @param eventName 'unsubscribed'
     * @param listener
     */
    on(eventName: 'unsubscribed', listener: () => void): this;
    /**
     * Can be used to re-subscribe with the same parameters.
     */
    subscribe(): Promise<void>;
    /**
     * Unsubscribes the subscription.
     */
    unsubscribe(): Promise<void>;
}
export declare class ProviderRpcClient {
    private readonly _api;
    private readonly _initializationPromise;
    private readonly _subscriptions;
    private readonly _contractSubscriptions;
    private _ton?;
    constructor();
    ensureInitialized(): Promise<void>;
    get isInitialized(): boolean;
    get raw(): Ton;
    get api(): ProviderApiMethods;
    createSubscriber(): Subscriber;
    subscribe(eventName: 'contractStateChanged', params: {
        address: Address;
    }): Promise<ISubscription<'contractStateChanged'>>;
    subscribe(eventName: 'transactionsFound', params: {
        address: Address;
    }): Promise<ISubscription<'transactionsFound'>>;
    subscribe(eventName: 'disconnected'): Promise<ISubscription<'disconnected'>>;
    subscribe(eventName: 'networkChanged'): Promise<ISubscription<'networkChanged'>>;
    subscribe(eventName: 'permissionsChanged'): Promise<ISubscription<'permissionsChanged'>>;
    subscribe(eventName: 'loggedOut'): Promise<ISubscription<'loggedOut'>>;
    private _getEventSubscriptions;
}
declare const provider: ProviderRpcClient;
export default provider;
