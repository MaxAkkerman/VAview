"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderRpcClient = exports.mergeTransactions = exports.hasTonProvider = exports.AddressLiteral = exports.Address = void 0;
const utils_1 = require("./utils");
const stream_1 = require("./stream");
__exportStar(require("./api"), exports);
__exportStar(require("./models"), exports);
__exportStar(require("./permissions"), exports);
__exportStar(require("./contract"), exports);
__exportStar(require("./stream"), exports);
var utils_2 = require("./utils");
Object.defineProperty(exports, "Address", { enumerable: true, get: function () { return utils_2.Address; } });
Object.defineProperty(exports, "AddressLiteral", { enumerable: true, get: function () { return utils_2.AddressLiteral; } });
let ensurePageLoaded;
if (document.readyState == 'complete') {
    ensurePageLoaded = Promise.resolve();
}
else {
    ensurePageLoaded = new Promise((resolve) => {
        window.addEventListener('load', () => {
            resolve();
        });
    });
}
async function hasTonProvider() {
    await ensurePageLoaded;
    return window.hasTonProvider === true;
}
exports.hasTonProvider = hasTonProvider;
/**
 * Modifies knownTransactions array, merging it with new transactions.
 * All arrays are assumed to be sorted by descending logical time.
 *
 * > Note! This method does not remove duplicates.
 *
 * @param knownTransactions
 * @param newTransactions
 * @param info
 */
function mergeTransactions(knownTransactions, newTransactions, info) {
    if (info.batchType == 'old') {
        knownTransactions.push(...newTransactions);
        return knownTransactions;
    }
    if (knownTransactions.length === 0) {
        knownTransactions.push(...newTransactions);
        return knownTransactions;
    }
    // Example:
    // known lts: [N, N-1, N-2, N-3, (!) N-10,...]
    // new lts: [N-4, N-5]
    // batch info: { minLt: N-5, maxLt: N-4, batchType: 'new' }
    // 1. Skip indices until known transaction lt is greater than the biggest in the batch
    let i = 0;
    while (i < knownTransactions.length &&
        knownTransactions[i].id.lt.localeCompare(info.maxLt) >= 0) {
        ++i;
    }
    // 2. Insert new transactions
    knownTransactions.splice(i, 0, ...newTransactions);
    return knownTransactions;
}
exports.mergeTransactions = mergeTransactions;
class ProviderRpcClient {
    constructor() {
        this._subscriptions = {};
        this._contractSubscriptions = {};
        this._api = new Proxy({}, {
            get: (_object, method) => (params) => this._ton.request({ method, params: params })
        });
        this._ton = window.ton;
        if (this._ton != null) {
            this._initializationPromise = Promise.resolve();
        }
        else {
            this._initializationPromise = hasTonProvider().then((hasTonProvider) => new Promise((resolve, reject) => {
                if (!hasTonProvider) {
                    reject(new Error('TON provider was not found'));
                    return;
                }
                this._ton = window.ton;
                if (this._ton != null) {
                    resolve();
                }
                else {
                    window.addEventListener('ton#initialized', (_data) => {
                        this._ton = window.ton;
                        resolve();
                    });
                }
            }));
        }
        this._initializationPromise.then(() => {
            if (this._ton == null) {
                return;
            }
            const knownEvents = [
                'disconnected',
                'transactionsFound',
                'contractStateChanged',
                'networkChanged',
                'permissionsChanged',
                'loggedOut'
            ];
            for (const eventName of knownEvents) {
                this._ton.addListener(eventName, (data) => {
                    const handlers = this._subscriptions[eventName];
                    if (handlers == null) {
                        return;
                    }
                    for (const handler of Object.values(handlers)) {
                        handler(data);
                    }
                });
            }
        });
    }
    async ensureInitialized() {
        await this._initializationPromise;
    }
    get isInitialized() {
        return this._ton != null;
    }
    get raw() {
        return this._ton;
    }
    get api() {
        return this._api;
    }
    createSubscriber() {
        return new stream_1.Subscriber(this);
    }
    async subscribe(eventName, params) {
        class Subscription {
            constructor(_subscribe, _unsubscribe) {
                this._subscribe = _subscribe;
                this._unsubscribe = _unsubscribe;
                this._listeners = {
                    ['data']: [],
                    ['subscribed']: [],
                    ['unsubscribed']: []
                };
            }
            on(eventName, listener) {
                this._listeners[eventName].push(listener);
                return this;
            }
            async subscribe() {
                await this._subscribe(this);
                for (const handler of this._listeners['subscribed']) {
                    handler();
                }
            }
            async unsubscribe() {
                await this._unsubscribe();
                for (const handler of this._listeners['unsubscribed']) {
                    handler();
                }
            }
            notify(data) {
                for (const handler of this._listeners['data']) {
                    handler(data);
                }
            }
        }
        let existingSubscriptions = this._getEventSubscriptions(eventName);
        const id = utils_1.getUniqueId();
        switch (eventName) {
            case 'disconnected':
            case 'networkChanged':
            case 'permissionsChanged':
            case 'loggedOut': {
                const subscription = new Subscription(async (subscription) => {
                    if (existingSubscriptions[id] != null) {
                        return;
                    }
                    existingSubscriptions[id] = (data) => {
                        subscription.notify(data);
                    };
                }, async () => {
                    delete existingSubscriptions[id];
                });
                await subscription.subscribe();
                return subscription;
            }
            case 'transactionsFound':
            case 'contractStateChanged': {
                const address = params.address.toString();
                const subscription = new Subscription(async (subscription) => {
                    if (existingSubscriptions[id] != null) {
                        return;
                    }
                    existingSubscriptions[id] = (data) => {
                        if (data.address == address) {
                            subscription.notify(data);
                        }
                    };
                    let contractSubscriptions = this._contractSubscriptions[address];
                    if (contractSubscriptions == null) {
                        contractSubscriptions = {};
                        this._contractSubscriptions[address] = contractSubscriptions;
                    }
                    contractSubscriptions[id] = {
                        state: eventName == 'contractStateChanged',
                        transactions: eventName == 'transactionsFound'
                    };
                    const { total, withoutExcluded } = foldSubscriptions(Object.values(contractSubscriptions), contractSubscriptions[id]);
                    try {
                        if (total.transactions != withoutExcluded.transactions || total.state != withoutExcluded.state) {
                            await this.api.subscribe({ address, subscriptions: total });
                        }
                    }
                    catch (e) {
                        delete existingSubscriptions[id];
                        delete contractSubscriptions[id];
                        throw e;
                    }
                }, async () => {
                    delete existingSubscriptions[id];
                    const contractSubscriptions = this._contractSubscriptions[address];
                    if (contractSubscriptions == null) {
                        return;
                    }
                    const updates = contractSubscriptions[id];
                    const { total, withoutExcluded } = foldSubscriptions(Object.values(contractSubscriptions), updates);
                    delete contractSubscriptions[id];
                    if (!withoutExcluded.transactions && !withoutExcluded.state) {
                        await this.api.unsubscribe({ address });
                    }
                    else if (total.transactions != withoutExcluded.transactions || total.state != withoutExcluded.state) {
                        await this.api.subscribe({ address, subscriptions: withoutExcluded });
                    }
                });
                await subscription.subscribe();
                return subscription;
            }
            default: {
                throw new Error(`Unknown event ${eventName}`);
            }
        }
    }
    _getEventSubscriptions(eventName) {
        let existingSubscriptions = this._subscriptions[eventName];
        if (existingSubscriptions == null) {
            existingSubscriptions = {};
            this._subscriptions[eventName] = existingSubscriptions;
        }
        return existingSubscriptions;
    }
}
exports.ProviderRpcClient = ProviderRpcClient;
function foldSubscriptions(subscriptions, except) {
    const total = { state: false, transactions: false };
    const withoutExcluded = Object.assign({}, total);
    for (const item of subscriptions) {
        if (withoutExcluded.transactions && withoutExcluded.state) {
            break;
        }
        total.state || (total.state = item.state);
        total.transactions || (total.transactions = item.transactions);
        if (item != except) {
            withoutExcluded.state || (withoutExcluded.state = item.state);
            withoutExcluded.transactions || (withoutExcluded.transactions = item.transactions);
        }
    }
    return { total, withoutExcluded };
}
const provider = new ProviderRpcClient();
exports.default = provider;
